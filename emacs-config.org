#+TITLE: Emacs Configuration
#+PROPERTY: header-args:emacs-lisp :tangle ./.emacs.d/init.el :mkdirp yes

* Base Configuration

Just the basics.

#+begin_src emacs-lisp

  ;; ===== BASE CONFIG =====

#+end_src

#+begin_src emacs-lisp

  ;; Disable backup files
  (setq make-backup-files nil)

  ;; Disable lock files
  (setq create-lockfiles nil)
   
  ;; Put auto-save files in a central location
  (make-directory (expand-file-name "tmp/auto-saves/" user-emacs-directory) t)
  (setq auto-save-file-name-transforms `((".*" ,(expand-file-name "tmp/auto-saves/" user-emacs-directory) t)))

  ;; Keep customization settings out of init.el
  (setq custom-file (locate-user-emacs-file "custom.el"))
  (when (file-exists-p custom-file)
    (load custom-file 'noerror 'nomessage))

  ;; Save command history between sessions
  (setq history-length 25)
  (savehist-mode 1)

  ;; Update buffers when underlying file has changed
  (global-auto-revert-mode 1)

  ;; Update non-file-visiting buffers when the underlying changes happen, such as Dired buffers
  (setq global-auto-revert-non-file-buffers t)

#+end_src

* Package System Configuration

Setup use-package.

#+begin_src emacs-lisp

  ;; ===== PACKAGE SYSTEM =====

#+end_src

#+begin_src emacs-lisp

  ;; Initialize package sources
  (require 'package)

  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
  			 ("nongnu" . "https://elpa.nongnu.org/nongnu/")
  			 ("elpa" . "https://elpa.gnu.org/packages/")))

  (package-initialize)

  (require 'use-package)
  (setq use-package-always-ensure t)

#+end_src

** Automatic Package Updates

Keep packages up to date automatically, prompting every 30 days.

#+begin_src emacs-lisp

  (use-package auto-package-update
    :custom
    (auto-package-update-interval 30)
    (auto-package-update-prompt-before-update t)
    (auto-package-update-hide-results t)
    :config
    (auto-package-update-maybe))

#+end_src

* Keybinding Configuration

Setup some spacemacs-y evil keybindings.

#+begin_src emacs-lisp

  ;; ===== KEYBINDINGS =====

#+end_src

#+begin_src emacs-lisp

  ;; Key-binding to open init.el
  (global-set-key (kbd "C-c e") (lambda () (interactive) (find-file "~/.emacs.d/init.el")))

  ;; Key-binding to make ESC quit prompts
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)

  (use-package evil
    :init
    (setq evil-want-integration t)
    (setq evil-want-keybinding nil)
    (setq evil-want-C-u-scroll t)
    (setq evil-want-C-i-jump nil)
    (setq evil-undo-system 'undo-redo)
    :config
    (evil-mode 1)

    ;; Use C-g to exit insert mode
    (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)

    ;; Use C-h as backspace in insert mode
    (define-key evil-insert-state-map (kbd "C-h") 'evil-delete-backward-char-and-join)

    ;; Add C-w u/U for winner-undo/redo
    (define-key evil-window-map (kbd "u") 'winner-undo)
    (define-key evil-window-map (kbd "U") 'winner-redo)

    ;; Use visual line motions even outside of visual-line-mode buffers
    (evil-global-set-key 'motion "j" 'evil-next-visual-line)
    (evil-global-set-key 'motion "k" 'evil-previous-visual-line)

    ;; Set default mode of certain buffer types to normal
    (evil-set-initial-state 'messages-buffer-mode 'normal)
    (evil-set-initial-state 'dashboard-mode 'normal))

  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init))

  ;; TODO add "s" to lal/leader-keys for save-buffer?
  (use-package general
    :after evil
    :config
    (general-create-definer lal/leader-keys
      :keymaps '(normal insert visual emacs)
      :prefix "SPC"
      :global-prefix "C-SPC")

    (lal/leader-keys
      "t"  '(:ignore t :which-key "toggles")
      "tt" '(counsel-load-theme :which-key "choose theme")
      "b"  '(:ignore t :which-key "buffers")
      "bb" '(counsel-switch-buffer :which-key "switch buffer")
      "bd" '(kill-current-buffer :which-key "delete buffer")
      "bk" '(kill-buffer :which-key "kill buffer (select)")
      "bn" '(next-buffer :which-key "next buffer")
      "bp" '(previous-buffer :which-key "previous buffer")
      "bm" '((lambda () (interactive) (switch-to-buffer "*Messages*")) :which-key "messages buffer")
      "w"  '(:ignore t :which-key "windows")
      "wl" '(evil-window-right :which-key "window right")
      "wh" '(evil-window-left :which-key "window left")
      "wj" '(evil-window-down :which-key "window down")
      "wk" '(evil-window-up :which-key "window up")
      "ws" '(evil-window-split :which-key "split horizontal")
      "wv" '(evil-window-vsplit :which-key "split vertial")
      "wd" '(evil-window-delete :which-key "delete window")))

#+end_src

* UI Configuration

Make it pretty.

#+begin_src emacs-lisp

  ;; ===== UI =====

#+end_src

** Basic

Make it minimalist.

#+begin_src emacs-lisp

  (setq inhibit-startup-message t)    ; Don't show startup screen

  (scroll-bar-mode -1)      ; Disable visible scrollbar
  (tool-bar-mode -1)        ; Disable the toolbar
  (tooltip-mode -1)         ; Disable tooltips
  (set-fringe-mode 10)      ; Give some breathing room

  (menu-bar-mode -1)        ; Disable the menu bar

  (desktop-save-mode 1)     ; Auto-save and restore sessions

  (setq use-dialog-box nil) ; Don't show dialog box prompts

  ;; Display line numbers
  (column-number-mode)
  (global-display-line-numbers-mode t)

  ;; Don't display line numbers for some modes
  (dolist (mode '(org-mode-hook
  		term-mode-hook
  		treemacs-mode-hook
  		shell-mode-hook
  		eshell-mode-hook))
    (add-hook mode (lambda () (display-line-numbers-mode 0))))

#+end_src

** Font Configuration

Use a nice monospace font.

#+begin_src emacs-lisp

  ;; Font face and size
  (set-face-attribute 'default nil :font "Fira Code Retina" :height 150)

#+end_src

** Theme

#+begin_src emacs-lisp

  (use-package doom-themes
    :init (load-theme 'doom-city-lights t))

#+end_src

*** TODO try modus-themes

** Better Modeline

Improve the modeline, adding nice icons.  Requires running =M-x nerd-icons-install-fonts= to get the icons.

#+begin_src emacs-lisp

  (use-package nerd-icons)

  (use-package doom-modeline
    :init (doom-modeline-mode 1)
    :custom (doom-modeline-height 30))

#+end_src

** Which Key

Adds the nice mini-buffer help displaying all possible completions for a give keybinding.

#+begin_src emacs-lisp
    
  (use-package which-key
    :init (which-key-mode)
    :diminish which-key-mode
    :config
    (setq which-key-idle-delay 0.3))

#+end_src

** Ivy and Counsel

Adds a completion framework, like helm.  Counsel makes ivy better with custom versions of emacs commands like ~counsel-find-file~. Ivy-rich gives nice descriptions of the commands in the completion buffer.

#+begin_src emacs-lisp

  (use-package ivy
    :diminish
    :bind (("C-s" . swiper)
    	 :map ivy-minibuffer-map
    	 ("TAB" . ivy-alt-done)
    	 ("C-l" . ivy-alt-done)
    	 ("C-j" . ivy-next-line)
    	 ("C-k" . ivy-previous-line)
    	 :map ivy-switch-buffer-map
    	 ("C-k" . ivy-previous-line)
    	 ("C-l" . ivy-done)
    	 ("C-d" . ivy-switch-buffer-kill)
    	 :map ivy-reverse-i-search-map
    	 ("C-k" . ivy-previous-line)
    	 ("C-d" . ivy-reverse-i-search-kill))
    :config
    (ivy-mode 1))

  (use-package ivy-rich
    :after ivy
    :init
    (ivy-rich-mode 1))

  (use-package counsel
    :bind (("M-x" . counsel-M-x)
    	 ("C-x b" . counsel-switch-buffer)
    	 ("C-x C-f" . counsel-find-file)
    	 :map minibuffer-local-map
    	 ("C-r" . 'counsel-minibuffer-history))
    :config
    (counsel-mode 1))

#+end_src

** Better candidate sorting and filtering

prescient.el improves sorting and filtering of candidate lists, like those displayed in the mini-buffer with =M-x= or =C-x C-f=.  Recently used items will be put at the beginning of the list, and filtering can be done by typing the first letters of each segment of a candidate, such as =cff= for =counsel-find-file=.

#+begin_src emacs-lisp

  (use-package ivy-prescient
    :after counsel
    :config
    (ivy-prescient-mode 1)
    (prescient-persist-mode 1))

#+end_src

** Helpful

Enhances the help buffers displayed by =describe-= commands.

#+begin_src emacs-lisp

  (use-package helpful
    :custom
    (counsel-describe-function-function #'helpful-callable)
    (counsel-describe-variable-function #'helpful-variable)
    :bind
    ([remap describe-function] . counsel-describe-function)
    ([remap describe-command] . helpful-command)
    ([remap describe-variable] . counsel-describe-variable)
    ([remap describe-key] . helpful-key))

#+end_src

** Text Zoom

Add transient keybinding, using hydra, for scaling the text size up and down.

#+begin_src emacs-lisp

  (use-package hydra)

  (defhydra hydra-text-zoom (:timeout 4)
    "zoom text"
    ("j" text-scale-increase "in")
    ("k" text-scale-decrease "out")
    ("f" nil "finished" :exit t))

  (lal/leader-keys
    "ts" '(hydra-text-zoom/body :which-key "zoom text"))

#+end_src

* Org Mode

Org-mode is incredible. I should really use it more.

#+begin_src emacs-lisp

  ;; ===== ORG MODE =====

#+end_src

** Font Faces

Fiddle with the font sizes of the bullet point hierarchy.

#+begin_src emacs-lisp

  (defun lal/org-font-setup ()
    ;; Set faces for org-mode heading levels
    (dolist (face '((org-level-1 . 1.2)
                    (org-level-2 . 1.1)
                    (org-level-3 . 1.05)
                    (org-level-4 . 1.0)
                    (org-level-5 . 1.1)
                    (org-level-6 . 1.1)
                    (org-level-7 . 1.1)
                    (org-level-8 . 1.1)))
      (set-face-attribute (car face) nil :font "Fira Code Retina" :weight 'regular :height (cdr face))))

#+end_src

** Basic

All kinds of org-mode setup:

- basic installation and setup and keybindings
- update TODO flow
- refile targets
- tag shortcuts
- custom org-agenda commands
- and capture templates for quick keybindings to capture certain things, like todos.

#+begin_src emacs-lisp

  (defun lal/org-mode-setup ()
    (org-indent-mode)
    (visual-line-mode 1))

  (use-package org
    :hook (org-mode . lal/org-mode-setup)
    :bind (("C-c a" . org-agenda)
  	 ("C-c c" . org-capture))
    :config
    (setq org-ellipsis " ▾")

    (setq org-agenda-start-with-log-mode t)
    (setq org-log-done 'time)
    (setq org-log-into-drawer t)

    (require 'org-habit)
    (add-to-list 'org-modules 'org-habit)
    (setq org-habit-graph-column 60)
    
    (setq org-agenda-files
  	'("~/code/me/org-mode-practice/tasks.org"
  	  "~/code/me/org-mode-practice/birthdays.org"
  	  "~/code/me/org-mode-practice/habits.org"))

    (setq org-todo-keywords
  	'((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")))

    (setq org-refile-targets
  	'(("archive.org" :maxlevel . 1)
  	  ("tasks.org" :maxlevel . 1)))

    ;; Save org buffers after a refile
    (advice-add 'org-refile :after 'org-save-all-org-buffers)

    (setq org-tag-alist
  	'((:startgroup)
  	  ;;Put mutually exclusive tags here
  	  (:endgroup)
  	  ("@errand" . ?E)
  	  ("@home" . ?H)
  	  ("@work" . ?W)
  	  ("agenda" . ?a)
  	  ("note" . ?n)
  	  ("idea" . ?i)))

    (setq org-agenda-custom-commands
  	'(("d" "Dashboard"
  	   ((agenda "" ((org-deadline-warning-days 7)))
  	    (todo "NEXT"
  		  ((org-agenda-overriding-header "Next Tasks")))
  	    (tags-todo "agenda/ACTIVE" ((org-agenda-overriding-header "Active Projects")))))

  	  ("n" "Next Tasks"
  	   ((todo "NEXT"
  		  ((org-agenda-overriding-header "Next Tasks")))))

  	  ("W" "Work Tasks" tags-todo "+work")

  	  ;; Low-effort next actions
  	  ("e" tags-todo "+TODO=\"NEXT\"+Effort<15&+Effort>0"
  	   ((org-agenda-overriding-header "Low Effort Tasks")
  	    (org-agenda-max-todos 20)
  	    (org-agenda-files org-agenda-files)))))

    (setq org-capture-templates
  	`(("t" "Tasks / Projects")
  	  ("tt" "Task" entry (file+olp "~/code/me/org-mode-practice/tasks.org" "Inbox")
  	   "* TODO %?\n  %U\n  %a\n  %i" :empty-lines 1)
  	  ("ts" "Clocked Entry Subtask" entry (clock)
  	   "* TODO %?\n  %U\n  %a\n  %i" :empty-lines 1)

  	  ("j" "Journal Entries")
  	  ("jj" "Journal" entry
  	   (file+olp+datetree "~/code/me/org-mode-practice/journal.org")
  	   "\n* %<%I:%M %p> - Journal :journal:\n\n%?\n\n"
  	   :clock-in :clock-resume
  	   :empty-lines 1)
  	  ("jm" "Meeting" entry
  	   (file+olp+datetree "~/code/me/org-mode-practice/journal.org")
  	   "* %<%I:%M %p> - %a :meetings:\n\n%?\n\n"
  	   :clock-in :clock-resume
  	   :empty-lines 1)

  	  ("w" "Workflows")
  	  ("we" "Checking Email" entry
  	   (file+olp+datetree "~/code/me/org-mode-practice/journal.org")
  	   "* Checking Email :email:\n\n%?"
  	   :clock-in :clock-resume
  	   :empty-lines 1)

  	  ("m" "Metrics Capture")
  	  ("mw" "Weight" table-line
  	   (file+headline "~/code/me/org-mode-practice/metrics.org" "Weight")
  	   "| %U | %^{Weight} | %^{Notes} |"
  	   :kill-buffer t)))
    
    (define-key global-map (kbd "C-c j")
  	      (lambda () (interactive (org-capture nil "jj"))))

    (lal/org-font-setup))

#+end_src

*** Bullets

Change the icons used for the bullets.

#+begin_src emacs-lisp

  (use-package org-bullets
    :hook (org-mode . org-bullets-mode)
    :custom
    (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))

#+end_src

** Configure Babel Languages

Add the ability to execute code for specific languages from org files.  Load after org-mode is loaded using =with-eval-after-load=.

#+begin_src emacs-lisp

  (with-eval-after-load 'org
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((shell . t )
       (emacs-lisp . t)
       (python . t)
       (js . t))))

#+end_src

** Structure Templates

Add shortcuts for adding code snippets for specific languages to org files.  Load after org-mode is loaded using =with-eval-after-load=.

#+begin_src emacs-lisp

  (with-eval-after-load 'org
    (require 'org-tempo)
    (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
    (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
    (add-to-list 'org-structure-template-alist '("js" . "src js"))
    (add-to-list 'org-structure-template-alist '("py" . "src python")))

#+end_src

** Auto-tangle Configuration Files

Automatically generate init.el, from the snippets in this file, anytime this file is saved.

#+begin_src emacs-lisp

  ;; Automatically tangle our Emacs.org config file when we save it
  (defun lal/org-babel-tangle-config ()
    (when (string-equal (buffer-file-name)
                        (expand-file-name "~/code/me/dotfiles/emacs-config.org"))
      ;; Dynamic scoping to the rescue
      (let ((org-confirm-babel-evaluate nil))
        (org-babel-tangle))))
  
  (add-hook 'org-mode-hook (lambda () (add-hook 'after-save-hook #'lal/org-babel-tangle-config)))

#+end_src

* Development

#+begin_src emacs-lisp

  ;; ===== DEVELOPMENT =====

#+end_src

** Languages

*** LSP Features

**** lsp-mode

Install lsp-mode to get language server protocol integration.

#+begin_src emacs-lisp

  (use-package lsp-mode
    :commands (lsp lsp-deferred)
    :init
    (setq lsp-keymap-prefix "C-c l")
    :config
    (lsp-enable-which-key-integration t))

#+end_src

***** TODO Switch to eglot?

**** lsp-ui

Adds UI enhancements for lsp-mode, like displaying symbols information and code actions in the sideline.

#+begin_src emacs-lisp

  (use-package lsp-ui
    :hook (lsp-mode . lsp-ui-mode)
    :custom
    (lsp-ui-doc-position 'bottom)
    (lsp-ui-doc-show-with-cursor t)
    (lsp-ui-doc-delay 0.5)
    (lsp-ui-sideline-show-code-actions t)
    (lsp-ui-sideline-delay 0.5))

#+end_src

**** lsp-treemacs

Add treemacs lsp integration so that tree views can be displayed of more than just the project file structure.  For instance, symbols, references, and diagnostic messages.

#+begin_src emacs-lisp

  (use-package lsp-treemacs
    :after lsp)
  
#+end_src

**** lsp-ivy

Enhance searching codebase for things like usages of a symbol.

#+begin_src emacs-lisp

  (use-package lsp-ivy
    :after lsp)

#+end_src

**** yasnippet

Add YASnippet to enable snippet support in lsp-mode.

#+begin_src emacs-lisp

  (use-package yasnippet
    :after lsp
    :hook((prog-mode . yas-minor-mode)
  	(text-mode . yas-minor-mode))
    :config
    (yas-reload-all))

  (use-package yasnippet-snippets
    :after yasnippet)

#+end_src

*** Debugging with dap-mode

Sets up dap-mode for debugging and a key-binding for the dap-hydra pane for easier keybindings while debugging.  Currently only setup for the NodeJS debuging.

This can pick up =.vscode/launch.json= debugger configs in NodeJS projects, but can also be paired with a =debug.el= that has a ~dap-register-debug-template~.

#+begin_src emacs-lisp

  (use-package dap-mode
    ;; Uncomment the config below to hide all debug UI panes by default
    ;; :custom
    ;; (lsp-enable-dap-auto-configure nil)
    ;; :config
    ;; (dap-ui-mode 1)

    ;; Delay loading package until used
    :commands dap-debug

    :config
    ;; Bind `C-c l d` to `dap-hydra` for easy access
    (general-define-key
     :keymaps 'lsp-mode-map
     :prefix lsp-keymap-prefix
     "d" '(dap-hydra t :wk "debugger")))

#+end_src

*** Javascript

Adds javascript support and enables lsp features and dap-mode for js2-mode.

#+begin_src emacs-lisp

  (use-package js2-mode
    :mode "\\.js\\'"
    :hook (js2-mode . lsp-deferred)
    :config
    (setq js2-basic-offset 2)

    ;; Let LSP handle errors
    (setq js2-mode-show-parse-errors nil)
    (setq js2-mode-show-strict-warnings nil)

    (require 'dap-node)
    (dap-node-setup))

#+end_src

*** Typescript

Adds typescript support to emacs and enables lsp features and dap-mode for typescript-mode.

#+begin_src emacs-lisp

  (use-package typescript-mode
    :mode "\\.ts\\'"
    :hook (typescript-mode . lsp-deferred)
    :config
    (setq typescript-indent-level 2)
    (require 'dap-node)
    (dap-node-setup))

#+end_src

**** TODO Emacs 29+ has built-in =typescript-ts-mode=, so this can probably get eliminated for something built-in using treesitter.

*** Go

Add Go support to emacs and enables lsp features and dap-mode for go-mode.

#+begin_src emacs-lisp

  (use-package go-mode
    :mode "\\.go\\'"
    :hook ((go-mode . lsp-deferred)
  	 (before-save . gfmt-before-save))
    :config
    (setq gofmt-command "goimports")
    (require 'dap-go)
    (dap-go-setup))

#+end_src

** Company Mode

Adds better code completion than the built-in =completion-at-point=.

#+begin_src emacs-lisp

  (use-package company
    :after lsp-mode
    :hook (lsp-mode . company-mode)
    :bind
    (:map company-active-map
    	("<tab>" . company-complete-selection))
    (:map lsp-mode-map
    	("<tab>" . company-indent-or-complete-common))
    :custom
    (company-minimum-prefix-length 1)
    (company-idle-delay 0.0)
    ;; Disable company-echo-metadata-frontend because the echo area refresh was jittery
    (company-frontends '(company-pseudo-tooltip-unless-just-one-frontend
  		       company-preview-frontend)))

  (use-package company-box
    :hook (company-mode . company-box-mode))

#+end_src

** Commenting

Better code commenting that adds the ability to comment one or multiple lines with using a keybinding.

#+begin_src emacs-lisp

  (use-package evil-nerd-commenter
    :bind ("M-/" . evilnc-comment-or-uncomment-lines))
  
#+end_src

** Projectile

Improve navigation of code projects.

#+begin_src emacs-lisp

  (use-package projectile
    :diminish projectile-mode
    :config
    (projectile-mode)
    (projectile-discover-projects-in-search-path)
    :custom ((projectile-completion-system 'ivy))
    :bind-keymap
    ("C-c p" . projectile-command-map)
    :init
    (when (file-directory-p "~/code/me")
      (setq projectile-project-search-path '("~/code/me")))
    (setq projectile-switch-project-action #'projectile-dired))

  (use-package counsel-projectile
    :after projectile
    :config (counsel-projectile-mode))

#+end_src

** Magit

Maybe the best git editor integration every.  Possibly the whole reason to use emacs at all.

#+begin_src emacs-lisp

  (use-package magit
    :commands magit-status
    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))

  (lal/leader-keys
    "g" '(:ignore t :which-key "git")
    "gs" '(magit-status :which-key "magit status")
    "gb" '(magit-blame :which-key "magit blame"))

#+end_src

** Rainbow Delimiters

Make it easier to match opening and closing delimiters, especially in lisp ;-)

#+begin_src emacs-lisp

  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))

#+end_src

* Terminals

#+begin_src emacs-lisp

  ;; ===== TERMINALS =====

#+end_src

** term-mode

Term is built-in, so it won't get installed, but we can use ~use-package~ to configure it.

#+begin_src emacs-lisp

  (use-package term
    :commands term
    :config
    (setq explicit-shell-file-name "bash")
    ;;(setq explicit-zsh-args '())
    (setq term-prompt-regexp "^[^#$%>❱\n]*[#$%>❱] *"))

#+end_src

*** Better term-mode colors

#+begin_src emacs-lisp

  (use-package eterm-256color
    :hook (term-mode . eterm-256color-mode))
  
#+end_src

** vterm

vterm is a better terminal emulator than term.  It's a native compiled module, so it's a bit faster. It's the best option for heavy terminal users.

#+begin_src emacs-lisp

  (use-package vterm
    :commands vterm
    :config
    (setq term-prompt-regexp "^[^#$%>❱\n]*[#$%>❱] *")
    ;;(setq vterm-shell "zsh")
    (setq vterm-max-scrollback 10000))
  
#+end_src

** eshell

eshell is a shell implementation in emacs lisp.  It works cross-platform, which is handy for getting GNU utilities in Windows.

It does not run interactive programs that present themselves visually well (i.e. vim, top, less, etc), but most of those are already setup in ~eshell-visual-commands~, and will open in a new term buffer. It's also not great a piping, and other unix-y type things.

It is also an Emacs Lisp REPL, so it can evaluate emacs lisp expressions.  

You can also open the current directory in =dired= by running =dired .=.

You can also pipe the output of a command to a buffer with something like =COMMAND > #<buffer BUFFER_NAME>=.

#+begin_src emacs-lisp

  (defun lal/configure-eshell()
    ;; Save command history when commands are entered
    (add-hook 'eshell-pre-command-hook 'eshell-save-some-history)

    ;; Truncate buffer for performance
    (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer)

    ;; Bind some useful keps for evil-mode
    (evil-define-key '(normal insert visual) eshell-mode-map (kbd "C-r") 'counsel-esh-history)
    (evil-define-key '(normal insert visual) eshell-mode-map (kbd "<home>") 'eshell-bol)
    (evil-normalize-keymaps)

    (setq eshell-history-size 10000
  	eshell-buffer-maximum-lines 10000
  	eshell-hist-ignoredups t
  	eshell-scroll-to-bottom-on-input 1))

  (use-package eshell-git-prompt
    :after eshell)

  (use-package eshell
    :hook (eshell-first-time-mode . lal/configure-eshell)
    :config

    (with-eval-after-load 'esh-opt
      (setq eshell-discover-buffer-when-process-dies t))
    
    (eshell-git-prompt-use-theme 'powerline))

#+end_src

* File Management

#+begin_src emacs-lisp

  ;; ===== FILE MGMT =====

#+end_src

** Dired

Dired is built-in. Using use-package to configure it, hence ~:ensure nil~.

#+begin_src emacs-lisp

  (use-package dired
    :ensure nil
    :commands (dired dired-jump)
    :bind (("C-x C-j" . dired-jump))
    :custom
    (dired-listing-switches "-alghoF")
    (dired-kill-when-opening-new-dired-buffer t)
    (delete-by-moving-to-trash t)
    :config
    (evil-collection-define-key 'normal 'dired-mode-map
      "h" 'dired-up-directory
      "l" 'dired-find-file))

  (use-package nerd-icons-dired
    :hook
    (dired-mode . nerd-icons-dired-mode))

#+end_src
